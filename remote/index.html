<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>MCP Client (Streamable HTTP)</title>
  <style>
    body { font-family: Arial, sans-serif; padding: 20px; }
    #output { margin-top: 20px; white-space: pre-wrap; border: 1px solid #ccc; padding: 10px; max-height: 400px; overflow-y: auto; }
    textarea, button, input { margin: 10px 0; display: block; }
    textarea { width: 100%; max-width: 500px; }
    .status { padding: 10px; margin: 10px 0; border-radius: 4px; }
    .status.connected { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
    .status.disconnected { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
    .status.connecting { background-color: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
  </style>
</head>
<body>
  <h1>MCP Client (Streamable HTTP Transport)</h1>
  <p>Connect to remote MCP servers using the official Streamable HTTP transport specification.</p>
  
  <div id="status" class="status disconnected">Disconnected</div>
  
  <input id="serverUrl" type="text" placeholder="MCP Server URL (e.g., https://api.example.com/mcp)" value="https://api.example.com/mcp">
  <button onclick="connect()">Connect to MCP Server</button>
  <button onclick="disconnect()">Disconnect</button>
  
  <h3>Available Tools</h3>
  <div id="tools"></div>
  
  <h3>Available Resources</h3>
  <div id="resources"></div>
  
  <h3>Available Prompts</h3>
  <div id="prompts"></div>
  
  <h3>Test Tool Call</h3>
  <select id="toolSelect">
    <option value="">Select a tool...</option>
  </select>
  <textarea id="toolArgs" rows="3" placeholder="Tool arguments (JSON)"></textarea>
  <button onclick="callTool()">Call Tool</button>
  
  <div id="output"></div>

  <script>
    class MCPStreamableHTTPClient {
      constructor() {
        this.serverUrl = null;
        this.sessionId = null;
        this.protocolVersion = '2025-06-18';
        this.requestId = 1;
        this.pendingRequests = new Map();
        this.sseStream = null;
        this.isConnected = false;
      }

      async connect(serverUrl) {
        this.serverUrl = serverUrl;
        this.updateStatus('connecting', 'Connecting...');
        
        try {
          // Initialize MCP session
          const initResponse = await this.initialize();
          
          if (initResponse.sessionId) {
            this.sessionId = initResponse.sessionId;
            log(`Session established: ${this.sessionId}`);
          }
          
          // Send initialized notification
          await this.sendNotification('notifications/initialized', {});
          
          // Start SSE stream for server-initiated messages
          await this.startSSEStream();
          
          // List available tools, resources, and prompts
          await this.listTools();
          await this.listResources();
          await this.listPrompts();
          
          this.isConnected = true;
          this.updateStatus('connected', 'Connected to MCP Server');
          
        } catch (error) {
          this.updateStatus('disconnected', `Connection failed: ${error.message}`);
          throw error;
        }
      }

      async initialize() {
        const request = {
          jsonrpc: '2.0',
          id: this.requestId++,
          method: 'initialize',
          params: {
            protocolVersion: this.protocolVersion,
            capabilities: {
              roots: { listChanged: true },
              sampling: {},
              elicitation: {}
            },
            clientInfo: {
              name: 'BrowserMCPClient',
              title: 'Browser MCP Client',
              version: '1.0.0'
            }
          }
        };

        const response = await this.sendRequest(request);
        return response.result;
      }

      async sendRequest(request) {
        const headers = {
          'Content-Type': 'application/json',
          'Accept': 'application/json, text/event-stream',
          'MCP-Protocol-Version': this.protocolVersion
        };

        if (this.sessionId) {
          headers['Mcp-Session-Id'] = this.sessionId;
        }

        const response = await fetch(this.serverUrl, {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(request)
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const contentType = response.headers.get('content-type');
        
        if (contentType && contentType.includes('text/event-stream')) {
          // Handle SSE stream response
          return await this.handleSSEResponse(response, request.id);
        } else {
          // Handle direct JSON response
          const result = await response.json();
          if (result.error) {
            throw new Error(`MCP Error: ${result.error.message}`);
          }
          return result;
        }
      }

      async sendNotification(method, params) {
        const notification = {
          jsonrpc: '2.0',
          method: method,
          params: params
        };

        const headers = {
          'Content-Type': 'application/json',
          'Accept': 'application/json, text/event-stream',
          'MCP-Protocol-Version': this.protocolVersion
        };

        if (this.sessionId) {
          headers['Mcp-Session-Id'] = this.sessionId;
        }

        const response = await fetch(this.serverUrl, {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(notification)
        });

        if (!response.ok) {
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        return response.status === 202; // 202 Accepted for notifications
      }

      async handleSSEResponse(response, requestId) {
        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        return new Promise((resolve, reject) => {
          const processChunk = () => {
            reader.read().then(({ done, value }) => {
              if (done) {
                reject(new Error('SSE stream ended without response'));
                return;
              }

              buffer += decoder.decode(value, { stream: true });
              const lines = buffer.split('\n');
              buffer = lines.pop(); // Keep incomplete line in buffer

              for (const line of lines) {
                if (line.startsWith('data: ')) {
                  try {
                    const data = JSON.parse(line.slice(6));
                    if (data.id === requestId) {
                      reader.cancel();
                      if (data.error) {
                        reject(new Error(`MCP Error: ${data.error.message}`));
                      } else {
                        resolve(data);
                      }
                      return;
                    }
                  } catch (e) {
                    // Skip invalid JSON lines
                  }
                }
              }

              processChunk();
            }).catch(reject);
          };

          processChunk();
        });
      }

      async startSSEStream() {
        const headers = {
          'Accept': 'text/event-stream',
          'MCP-Protocol-Version': this.protocolVersion
        };

        if (this.sessionId) {
          headers['Mcp-Session-Id'] = this.sessionId;
        }

        const response = await fetch(this.serverUrl, {
          method: 'GET',
          headers: headers
        });

        if (!response.ok) {
          if (response.status === 405) {
            log('Server does not support SSE stream');
            return;
          }
          throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }

        const reader = response.body.getReader();
        const decoder = new TextDecoder();
        let buffer = '';

        const processSSE = () => {
          reader.read().then(({ done, value }) => {
            if (done) {
              log('SSE stream closed');
              return;
            }

            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split('\n');
            buffer = lines.pop();

            for (const line of lines) {
              if (line.startsWith('data: ')) {
                try {
                  const data = JSON.parse(line.slice(6));
                  this.handleServerMessage(data);
                } catch (e) {
                  // Skip invalid JSON lines
                }
              }
            }

            processSSE();
          }).catch(error => {
            log(`SSE error: ${error.message}`);
          });
        };

        processSSE();
        this.sseStream = response;
      }

      handleServerMessage(message) {
        log(`Server message: ${JSON.stringify(message, null, 2)}`);
        
        if (message.method) {
          // Handle server requests/notifications
          if (message.method === 'ping') {
            this.sendNotification('pong', {});
          }
        }
      }

      async listTools() {
        try {
          const response = await this.sendRequest({
            jsonrpc: '2.0',
            id: this.requestId++,
            method: 'tools/list',
            params: {}
          });

          const tools = response.result.tools || [];
          this.displayTools(tools);
          log(`Found ${tools.length} tools`);
        } catch (error) {
          log(`Error listing tools: ${error.message}`);
        }
      }

      async listResources() {
        try {
          const response = await this.sendRequest({
            jsonrpc: '2.0',
            id: this.requestId++,
            method: 'resources/list',
            params: {}
          });

          const resources = response.result.resources || [];
          this.displayResources(resources);
          log(`Found ${resources.length} resources`);
        } catch (error) {
          log(`Error listing resources: ${error.message}`);
        }
      }

      async listPrompts() {
        try {
          const response = await this.sendRequest({
            jsonrpc: '2.0',
            id: this.requestId++,
            method: 'prompts/list',
            params: {}
          });

          const prompts = response.result.prompts || [];
          this.displayPrompts(prompts);
          log(`Found ${prompts.length} prompts`);
        } catch (error) {
          log(`Error listing prompts: ${error.message}`);
        }
      }

      async callTool(toolName, args) {
        const response = await this.sendRequest({
          jsonrpc: '2.0',
          id: this.requestId++,
          method: 'tools/call',
          params: {
            name: toolName,
            arguments: args
          }
        });

        return response.result;
      }

      displayTools(tools) {
        const container = document.getElementById('tools');
        container.innerHTML = '';

        tools.forEach(tool => {
          const div = document.createElement('div');
          div.innerHTML = `
            <strong>${tool.name}</strong>: ${tool.description}
            <br><small>Input: ${JSON.stringify(tool.inputSchema)}</small>
          `;
          container.appendChild(div);

          // Add to tool selector
          const option = document.createElement('option');
          option.value = tool.name;
          option.textContent = tool.name;
          document.getElementById('toolSelect').appendChild(option);
        });
      }

      displayResources(resources) {
        const container = document.getElementById('resources');
        container.innerHTML = '';

        resources.forEach(resource => {
          const div = document.createElement('div');
          div.innerHTML = `
            <strong>${resource.uri}</strong>: ${resource.name || 'Unnamed'}
            <br><small>${resource.description || 'No description'}</small>
          `;
          container.appendChild(div);
        });
      }

      displayPrompts(prompts) {
        const container = document.getElementById('prompts');
        container.innerHTML = '';

        prompts.forEach(prompt => {
          const div = document.createElement('div');
          div.innerHTML = `
            <strong>${prompt.name}</strong>: ${prompt.description}
            <br><small>Arguments: ${JSON.stringify(prompt.arguments || [])}</small>
          `;
          container.appendChild(div);
        });
      }

      updateStatus(type, message) {
        const status = document.getElementById('status');
        status.className = `status ${type}`;
        status.textContent = message;
      }

      disconnect() {
        if (this.sseStream) {
          this.sseStream.body.getReader().cancel();
          this.sseStream = null;
        }
        
        if (this.sessionId) {
          // Send DELETE request to terminate session
          fetch(this.serverUrl, {
            method: 'DELETE',
            headers: {
              'Mcp-Session-Id': this.sessionId,
              'MCP-Protocol-Version': this.protocolVersion
            }
          }).catch(() => {
            // Ignore errors when terminating session
          });
        }

        this.isConnected = false;
        this.sessionId = null;
        this.updateStatus('disconnected', 'Disconnected');
        log('Disconnected from MCP server');
      }
    }

    // Global client instance
    let mcpClient = new MCPStreamableHTTPClient();

    async function connect() {
      const serverUrl = document.getElementById('serverUrl').value;
      if (!serverUrl) {
        log('Error: Server URL required');
        return;
      }

      try {
        await mcpClient.connect(serverUrl);
      } catch (error) {
        log(`Connection failed: ${error.message}`);
      }
    }

    async function disconnect() {
      mcpClient.disconnect();
    }

    async function callTool() {
      const toolName = document.getElementById('toolSelect').value;
      const argsText = document.getElementById('toolArgs').value;

      if (!toolName) {
        log('Error: Please select a tool');
        return;
      }

      if (!mcpClient.isConnected) {
        log('Error: Not connected to MCP server');
        return;
      }

      try {
        let args = {};
        if (argsText.trim()) {
          args = JSON.parse(argsText);
        }

        log(`Calling tool: ${toolName} with args: ${JSON.stringify(args)}`);
        const result = await mcpClient.callTool(toolName, args);
        log(`Tool result: ${JSON.stringify(result, null, 2)}`);
      } catch (error) {
        log(`Tool call failed: ${error.message}`);
      }
    }

    function log(message) {
      const output = document.getElementById('output');
      output.textContent += new Date().toISOString() + ': ' + message + '\n';
      output.scrollTop = output.scrollHeight;
    }
  </script>
</body>
</html>
